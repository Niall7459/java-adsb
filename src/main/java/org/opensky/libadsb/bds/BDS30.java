package org.opensky.libadsb.bds;

import org.opensky.libadsb.exceptions.BadFormatException;
import org.opensky.libadsb.msgs.AltitudeReply;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;

/**
 * Parser for BDS 3,0 registers (ACAS active resolution advisory)
 * <br><br>
 * Note: most of the code was copied from the ADS-B decoders!
 *
 * @author Matthias Schäfer (schaefer@opensky-network.org)
 * @author Markus Fuchs (fuchs@opensky-network.org)
 */
public class BDS30 extends BinaryDataStore {

    private byte threat_id_type;
    private int threat_id;
    private boolean ra_terminated;
    private boolean multiple_threats;

    private boolean b41;
    private boolean b42;
    private boolean b43;
    private boolean b44;
    private boolean b45;
    private boolean b46;
    private boolean b47;

    private boolean noPassBelow;
    private boolean noPassAbove;
    private boolean noTurnLeft;
    private boolean noTurnRight;

    public BDS30(byte[] payload) throws BadFormatException {
        super(payload);
        setBDSSelector((byte) 0x30);

        if (payload[0] != 0x30)
            throw new BadFormatException(String.format("Wrong BDS code (%02x), expected 3,0.", payload[0]));

        int active_ras = (short) (((payload[1] & 0xff) << 6) | ((payload[2] & 0xfc) >> 2));

        // bits 48-54
        if ((active_ras & 0x7f) > 0)
            throw new BadFormatException("ACAS III reserved fields are not zero!");

        // the bits according to Annex 10 V4 (4.3.8.4.2.2.)
        b41 = (active_ras & 0x2000) > 0;
        b42 = (active_ras & 0x1000) > 0;
        b43 = (active_ras & 0x0800) > 0;
        b44 = (active_ras & 0x0400) > 0;
        b45 = (active_ras & 0x0200) > 0;
        b46 = (active_ras & 0x0100) > 0;
        b47 = (active_ras & 0x0080) > 0;

        byte racs_record = (byte) (((payload[2] & 0x03) << 2) | ((payload[3] & 0xc0) >> 6));
        noPassBelow = (racs_record & 0x8) > 0;
        noPassAbove = (racs_record & 0x4) > 0;
        noTurnLeft = (racs_record & 0x2) > 0;
        noTurnRight = (racs_record & 0x1) > 0;

        ra_terminated = (payload[3] & 0x20) > 0;
        multiple_threats = (payload[3] & 0x10) > 0;

        threat_id_type = (byte) ((payload[3] & 0x0c) >> 2);
        threat_id = ((payload[3] & 0x3) << 24) |
                ((payload[4] & 0xff) << 16) |
                ((payload[5] & 0xff) << 8) |
                (payload[6] & 0xff);

        if (threat_id_type == 2 && (threat_id & 0x80000) > 0)
            throw new BadFormatException("X bit in altitude code must be zero.");

        if (threat_id_type == 2 && (threat_id & 0x3f) > 60)
            throw new BadFormatException("Invalid bearing!");

        if (threat_id_type == 0 && threat_id != 0)
            throw new BadFormatException("Thread ID is not zero, although indicated by ID.");

        if (threat_id_type == 3)
            throw new BadFormatException("Unassigned thread ID was used.");
    }

    /**
     * ARA bit 41 according to Annex 10 V4 4.3.8.4.2.2.1.1
     *
     * false indicates either no threats or multiple threats (if {@link #hasMultipleThreats()} is true).
     * true indicates that there is a single threat.
     *
     * In combination with {@link #hasMultipleThreats()} (MTE), this field is subject to the following semantics:
     *   MTE=0, ARA41=0: there is no threat
     *   MTE=0, ARA41=1: there is a single threat
     *   MTE=1, ARA41=0: there are multiple threats, some threats need above and some below separation
     *   MTE=1, ARA41=1: there are multiple threats, RA is intended to provide separation for all threats
     */
    public boolean hasActiveRA() {
        return b41;
    }

    /**
     * Multiple Threat Encounter (MTE) flag according to Annex 10 V4 4.3.8.4.2.2.1.4
     * @return true if two or more threats are being processed
     */
    public boolean hasMultipleThreats() {
        return multiple_threats;
    }

    /**
     * The RA terminated flag according to Annex 10 V4 4.3.8.4.2.2.1.3
     *
     * After an RA has been terminated by ACAS, it is still required to be reported by the Mode S transponder for 18±1 s
     * (4.3.11.4.1).
     * RAs may terminate for a number of reasons: normally, when the conflict has been resolved and the threat is
     * diverging in range; or when the threat’s Mode S transponder for some reason ceases to report altitude during
     * the conflict. The RA terminated indicator is used to show that the RA has been removed in each of these cases.
     *
     * @return true when an RA previously generated by ACAS has ceased being generated.
     */
    public boolean isRATerminated() {
        return ra_terminated;
    }

    /**
     * @return ICAO 24-bit address of threat's Mode S transponder or null if address not available
     */
    public Integer getThreatICAO24 () {
        if (threat_id_type != 1)
            return null;
        else
            return threat_id>>2;
    }

    /**
     * @return true iff bearing, range, and altitude are available in this RA
     */
    public boolean hasThreatBRA() {
        return threat_id_type == 2;
    }

    /**
     * @return the altitude in feet if available, null otherwise
     */
    public Integer getThreatAltitude() {
        if (threat_id_type == 2)
            return AltitudeReply.decodeAltitude((short) (threat_id>>13));
        else return null;
    }

    /**
     * @return most recent threat range in NM according to ICAO Annex 10 V4 §4.3.8.4.2.2.1.6.2; null if not available
     */
    public Double getThreatRange() {
        byte n = (byte) ((threat_id & 0x1fc0) >> 6);

        if (threat_id_type != 2 || n == 0)
            return null;
        else if (n == 1)
            return 0.05;
        else if (n < 127)
            return (n-1)/10.;
        else return 12.55;
    }

    /**
     * @return bearing in degrees or null if not available
     */
    public Double getThreatBearing() {
        byte n = (byte) (threat_id & 0x3f);

        if (threat_id_type == 2 && n > 0 && n < 61)
            return 6.*n - 0.5;
        else return null;
    }

    private String getThreatIDTypeString () {
        switch (threat_id_type) {
            case 0:
                return "No data";
            case 1:
                return "Mode S address";
            case 2:
                return "Bearing, Range, Altitude";
            default:
                return "Unassigned";
        }
    }

    /**
     * Interpretation of RA flags (bits 42 to 54).
     * Values have the following semantics according to Annex 10 V4 4.3.8.4.2.2.1.1
     *
     * PREVENTIV            - RA is preventive
     * CORRECTIV            - RA is corrective
     * UP_SENSE_GEN         - Upward sense RA has been generated
     * DOWN_SENSE_GE        - Downward sense RA has been generated
     * NO_INCR_RATE         - RA is not increased rate
     * INCR_RATE            - RA is increased rate
     * NO_SENSE_REV         - RA is not a sense reversal
     * SENSE_REV            - RA is a sense reversal
     * NO_ALT_CROSS         - RA is not altitude crossing
     * ALT_CROSS            - RA is altitude crossing
     * VERT_SPEED_LI        - RA is vertical speed limit
     * POSITIVE             - RA is positive
     * NO_CORR_UP_SENSE,    - RA does not require a correction in the upward sense
     * CORR_UP_SENSE        - RA requires a correction in the upward sense
     * NO_POS_CLIMB         - RA does not require a positive climb
     * POS_CLIMB            - RA requires a positive climb
     * NO_CORR_DOWN_SENSE   - RA does not require a correction in the downward sense
     * CORR_DOWN_SENSE      - RA drequires a correction in the downward sense
     * NO_POS_DESC          - RA does not require a positive descend
     * POS_DESC             - RA requires a positive descend
     * NO_CROSS             - RA does not require a crossing
     * CROSS                - RA requires a crossing
     */
    public enum RA {
        // b41 = 1
        CORRECTIVE,
        PREVENTIVE,
        DOWN_SENSE_GEN,
        UP_SENSE_GEN,
        NO_INCR_RATE,
        INCR_RATE,
        NO_SENSE_REV,
        SENSE_REV,
        NO_ALT_CROSS,
        ALT_CROSS,
        VERT_SPEED_LIM,
        POSITIVE,

        // b41 == 0 and MTE = 1
        NO_CORR_UP_SENSE,
        CORR_UP_SENSE,
        NO_POS_CLIMB,
        POS_CLIMB,
        NO_CORR_DOWN_SENSE,
        CORR_DOWN_SENSE,
        NO_POS_DESC,
        POS_DESC,
        NO_CROSS,
        CROSS,
        // from above NO_SENSE_REV,
        // from above SENSE_REV
    }

    /**
     * Get all fields of the Resolution Advisory (RA) according to Annex 10 V4 4.3.8.4.2.2.1.1
     */
    public Set<RA> getResolutionAdvisory() {
        Set<RA> ra = new HashSet<RA>(6);

        if (b41) {
            ra.add(b42 ? RA.CORRECTIVE : RA.PREVENTIVE);
            ra.add(b43 ? RA.DOWN_SENSE_GEN : RA.UP_SENSE_GEN);
            ra.add(b44 ? RA.INCR_RATE : RA.NO_INCR_RATE);
            ra.add(b45 ? RA.SENSE_REV : RA.NO_SENSE_REV);
            ra.add(b46 ? RA.ALT_CROSS : RA.NO_ALT_CROSS);
            ra.add(b47 ? RA.POSITIVE : RA.VERT_SPEED_LIM);
        } else if (multiple_threats) {
            ra.add(b42 ? RA.CORR_UP_SENSE : RA.NO_CORR_UP_SENSE);
            ra.add(b43 ? RA.POS_CLIMB : RA.NO_POS_CLIMB);
            ra.add(b44 ? RA.CORR_DOWN_SENSE : RA.NO_CORR_DOWN_SENSE);
            ra.add(b45 ? RA.POS_DESC : RA.NO_POS_DESC);
            ra.add(b46 ? RA.CROSS : RA.NO_CROSS);
            ra.add(b47 ? RA.SENSE_REV : RA.NO_SENSE_REV);
        }

        return ra;
    }

    /**
     * Interpretation of the Resolution Advisory Complement (RAC) flags according to Annex 10 V4 4.3.8.4.2.2.1.2
     */
    public enum RAC {
        NO_PASS_BELOW,
        NO_PASS_ABOVE,
        NO_TURN_LEFT,
        NO_TURN_RIGHT
    }

    /**
     * Get all fields of the Resolution Advisory Complement (RAC) according to Annex 10 V4 4.3.8.4.2.2.1.2
     */
    public Set<RAC> getResolutionAdvisoryComplement() {
        Set<RAC> rac = new HashSet<RAC>(4);

        if (noPassAbove) rac.add(RAC.NO_PASS_ABOVE);
        if (noPassBelow) rac.add(RAC.NO_PASS_BELOW);
        if (noTurnLeft) rac.add(RAC.NO_TURN_LEFT);
        if (noTurnRight) rac.add(RAC.NO_TURN_RIGHT);

        return rac;
    }

    public String toString() {
        StringBuilder ret = new StringBuilder();

        ret.append(super.toString());
        ret.append("\nBDS3,0:\n");
        ret.append(String.format("\tThread ID Type:\t%s\n", getThreatIDTypeString()));
        if (threat_id_type == 1)
            ret.append(String.format("\tThreat's transponder address:\t%06x\n", getThreatICAO24()));
        ret.append(String.format("\tHas threat BRA:\t%b\n", hasThreatBRA()));
        if (hasThreatBRA()) {
            ret.append(String.format("\tAltitude:\t%s ft\n", getThreatAltitude()));
            ret.append(String.format("\tRange:\t%s NM\n", getThreatRange()));
            ret.append(String.format("\tBearing:\t%s degrees\n", getThreatBearing()));
        }
        ret.append(String.format("\tNumber of threats:\t%s\n", multiple_threats ? "> 1" : (b41 ? "1" : "0")));

        // decode RA info
        if (!multiple_threats && !b41)
            ret.append("\tNo RA has been generated.");
        else if (ra_terminated)
            ret.append("\tThe following RA has been terminated:");
        else ret.append("\tThe following RA is currently being generated:");

        if (b41) {
            ret.append(String.format("\n\t\tRA is %s", b42 ? "corrective" : "preventive"));
            ret.append(String.format("\n\t\t%s sense RA has been generated", b43 ? "Downward" : "Upward"));
            ret.append(String.format("\n\t\tRA is %sincreased rate", b44 ? "" : "not "));
            ret.append(String.format("\n\t\tRA is %sa sense reversal", b45 ? "" : "not "));
            ret.append(String.format("\n\t\tRA is %saltitude crossing", b46 ? "" : "not "));
            ret.append(String.format("\n\t\tRA is %s", b47 ? "positive" : "vertical speed limit"));
        } else if (multiple_threats) {
            ret.append(String.format("\n\t\tRA %s a correction in the upward sense", b42 ? "requires" : "does not require"));
            ret.append(String.format("\n\t\tRA %s a positive climb", b43 ? "requires" : "does not require"));
            ret.append(String.format("\n\t\tRA %s a correction in the downward sense", b44 ? "requires" : "does not require"));
            ret.append(String.format("\n\t\tRA %s a positive descend", b45 ? "requires" : "does not require"));
            ret.append(String.format("\n\t\tRA %s a crossing", b46 ? "requires" : "does not require"));
            ret.append(String.format("\n\t\tRA is %sa sense reversal", b47 ? "" : "not "));
        }

        ArrayList<String> racs = new ArrayList<String>(4);
        if (noPassBelow) racs.add("no pass below");
        if (noPassAbove) racs.add("no pass above");
        if (noTurnLeft) racs.add("no turn left");
        if (noTurnRight) racs.add("no turn right");
        if (!noPassBelow && !noPassAbove && !noTurnLeft && !noTurnRight) racs.add("none");
        ret.append("\n\tActive RA complements: ").append(racs.toString());

        return ret.toString();
    }

}
